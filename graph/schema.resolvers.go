package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"

	"github.com/kaigoh/monate/v2/graph/model"
	"github.com/kaigoh/monate/v2/internal/data"
	"github.com/kaigoh/monate/v2/internal/moneropay"
)

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.CreateStoreInput) (*model.Store, error) {
	store := &data.Store{
		Name:              input.Name,
		Slug:              strings.ToLower(input.Slug),
		PublicURL:         input.PublicURL,
		MoneroPayEndpoint: strings.TrimRight(input.MoneroPayEndpoint, "/"),
		MoneroPayAPIKey:   input.MoneroPayAPIKey,
		Theme:             applyThemeInput(data.ThemeSettings{}, input.Theme),
	}

	if err := r.DB.WithContext(ctx).Create(store).Error; err != nil {
		return nil, err
	}

	return toModelStore(store), nil
}

// UpdateStoreTheme is the resolver for the updateStoreTheme field.
func (r *mutationResolver) UpdateStoreTheme(ctx context.Context, input model.UpdateStoreThemeInput) (*model.Store, error) {
	storeID, err := uuid.Parse(input.StoreID)
	if err != nil {
		return nil, fmt.Errorf("invalid store id: %w", err)
	}

	var store data.Store
	if err := r.DB.WithContext(ctx).First(&store, "id = ?", storeID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("store %s not found", input.StoreID)
		}
		return nil, err
	}

	store.Theme = applyThemeInput(store.Theme, input.Theme)
	if err := r.DB.WithContext(ctx).Save(&store).Error; err != nil {
		return nil, err
	}

	return toModelStore(&store), nil
}

// CreateInvoice is the resolver for the createInvoice field.
func (r *mutationResolver) CreateInvoice(ctx context.Context, input model.CreateInvoiceInput) (*model.Invoice, error) {
	storeID, err := uuid.Parse(input.StoreID)
	if err != nil {
		return nil, fmt.Errorf("invalid store id: %w", err)
	}

	var store data.Store
	if err := r.DB.WithContext(ctx).First(&store, "id = ?", storeID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("store %s not found", input.StoreID)
		}
		return nil, err
	}

	invoiceID := uuid.New()
	invoice := &data.Invoice{
		ID:             invoiceID,
		StoreID:        storeID,
		Store:          store,
		Description:    stringFromPtr(input.Description),
		Reference:      stringFromPtr(input.Reference),
		AmountAtomic:   int64(input.AmountAtomic),
		FiatAmount:     input.FiatAmount,
		Currency:       strings.ToUpper(input.Currency),
		Status:         data.InvoiceStatusPending,
		NextCheckAt:    time.Now().UTC(),
		ExpectedAmount: int64(input.AmountAtomic),
	}

	callbackURL := fmt.Sprintf("%s/webhooks/moneropay/%s?invoice=%s",
		strings.TrimRight(r.Config.PublicBaseURL, "/"),
		store.CallbackSecret,
		invoice.ID.String(),
	)

	client := moneropay.NewClient(store.MoneroPayEndpoint, store.MoneroPayAPIKey)
	resp, err := client.CreateInvoice(ctx, moneropay.ReceiveRequest{
		Amount:      invoice.AmountAtomic,
		Description: invoice.Description,
		CallbackURL: callbackURL,
	})
	if err != nil {
		return nil, err
	}

	invoice.MoneroPayAddress = resp.Address
	invoice.CallbackURL = callbackURL

	if err := r.DB.WithContext(ctx).Create(invoice).Error; err != nil {
		return nil, err
	}

	if r.Notifier != nil {
		r.Notifier.Publish(invoice)
	}

	return toModelInvoice(invoice), nil
}

// Stores is the resolver for the stores field.
func (r *queryResolver) Stores(ctx context.Context) ([]*model.Store, error) {
	var stores []data.Store
	if err := r.DB.WithContext(ctx).Find(&stores).Error; err != nil {
		return nil, err
	}

	result := make([]*model.Store, 0, len(stores))
	for idx := range stores {
		result = append(result, toModelStore(&stores[idx]))
	}
	return result, nil
}

// Store is the resolver for the store field.
func (r *queryResolver) Store(ctx context.Context, id string) (*model.Store, error) {
	storeID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid store id: %w", err)
	}
	var store data.Store
	if err := r.DB.WithContext(ctx).First(&store, "id = ?", storeID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return toModelStore(&store), nil
}

// Invoices is the resolver for the invoices field.
func (r *queryResolver) Invoices(ctx context.Context, storeID string) ([]*model.Invoice, error) {
	id, err := uuid.Parse(storeID)
	if err != nil {
		return nil, fmt.Errorf("invalid store id: %w", err)
	}

	var invoices []data.Invoice
	if err := r.DB.WithContext(ctx).
		Preload("Store").
		Where("store_id = ?", id).
		Order("created_at DESC").
		Find(&invoices).Error; err != nil {
		return nil, err
	}

	result := make([]*model.Invoice, 0, len(invoices))
	for idx := range invoices {
		result = append(result, toModelInvoice(&invoices[idx]))
	}
	return result, nil
}

// Invoice is the resolver for the invoice field.
func (r *queryResolver) Invoice(ctx context.Context, id string) (*model.Invoice, error) {
	invoiceID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid invoice id: %w", err)
	}

	var invoice data.Invoice
	if err := r.DB.WithContext(ctx).
		Preload("Store").
		First(&invoice, "id = ?", invoiceID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return toModelInvoice(&invoice), nil
}

// InvoiceStatus is the resolver for the invoiceStatus field.
func (r *subscriptionResolver) InvoiceStatus(ctx context.Context, invoiceID string) (<-chan *model.Invoice, error) {
	if r.Notifier == nil {
		return nil, fmt.Errorf("subscriptions are disabled")
	}

	id, err := uuid.Parse(invoiceID)
	if err != nil {
		return nil, fmt.Errorf("invalid invoice id: %w", err)
	}

	var invoice data.Invoice
	if err := r.DB.WithContext(ctx).Preload("Store").First(&invoice, "id = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("invoice %s not found", invoiceID)
		}
		return nil, err
	}

	updateCh, cleanup := r.Notifier.Subscribe(id)
	out := make(chan *model.Invoice, 1)

	go func(initial *data.Invoice) {
		defer close(out)
		defer cleanup()
		out <- toModelInvoice(initial)

		for {
			select {
			case <-ctx.Done():
				return
			case inv, ok := <-updateCh:
				if !ok {
					return
				}
				out <- toModelInvoice(inv)
			}
		}
	}(&invoice)

	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

func stringFromPtr(value *string) string {
	if value == nil {
		return ""
	}
	return *value
}
